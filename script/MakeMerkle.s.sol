// SPDX-License-Identifier: MIT

pragma solidity ^0.8.24;

import {Script} from "forge-std/Script.sol";
import {stdJson} from "forge-std/StdJson.sol";
import {console} from "forge-std/console.sol";
import {Merkle} from "murky/src/Merkle.sol";
import {ScriptHelper} from "murky/script/common/ScriptHelper.sol";

/**
 * @title MakeMerkle
 * @author Hash-Hokage
 * @notice Generates Merkle proofs and root hash from the input whitelist data
 * @dev This script reads the input JSON file generated by GenerateInput.s.sol,
 *      constructs a Merkle tree, and outputs the proofs and root hash.
 *
 *      Original Work by:
 *      @author kootsZhin
 *      @notice https://github.com/dmfxyz/murky
 *
 *      Usage:
 *      1. First run `forge script script/GenerateInput.s.sol` to create input.json
 *      2. Run `forge script script/MakeMerkle.s.sol`
 *      3. The output will be written to /script/target/output.json
 *
 *      The output contains:
 *      - Merkle root hash (used in MerkleAirdrop constructor)
 *      - Individual proofs for each whitelisted address
 *      - Leaf hashes for verification
 *
 *      Leaf Hash Construction:
 *      - Each leaf is: keccak256(bytes.concat(keccak256(abi.encode(address, amount))))
 *      - Double hashing prevents second preimage attacks
 */
contract MakeMerkle is Script, ScriptHelper {
    using stdJson for string;

    /*//////////////////////////////////////////////////////////////
                            STATE VARIABLES
    //////////////////////////////////////////////////////////////*/

    /// @notice Instance of the Merkle contract from Murky library
    Merkle private m = new Merkle();

    /// @notice Relative path to the input JSON file
    string private inputPath = "/script/target/input.json";

    /// @notice Relative path to the output JSON file
    string private outputPath = "/script/target/output.json";

    /// @notice Raw JSON content read from the input file
    string private elements = vm.readFile(string.concat(vm.projectRoot(), inputPath));

    /// @notice Array of data types for leaf construction (["address", "uint"])
    string[] private types = elements.readStringArray(".types");

    /// @notice Number of leaf nodes in the Merkle tree
    uint256 private count = elements.readUint(".count");

    /// @notice Array to store computed leaf hashes
    bytes32[] private leafs = new bytes32[](count);

    /// @notice Array to store stringified input values for each leaf
    string[] private inputs = new string[](count);

    /// @notice Array to store generated JSON entries for output
    string[] private outputs = new string[](count);

    /// @notice Final stringified JSON output
    string private output;

    /*//////////////////////////////////////////////////////////////
                           INTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Constructs the JSON path for accessing input values
     * @dev Returns a path like ".values.0.1" for accessing the amount of the first entry
     * @param i The index of the whitelist entry
     * @param j The index of the value (0 = address, 1 = amount)
     * @return The constructed JSON path string
     */
    function getValuesByIndex(uint256 i, uint256 j) internal pure returns (string memory) {
        return string.concat(".values.", vm.toString(i), ".", vm.toString(j));
    }

    /**
     * @notice Generates a JSON entry for a single leaf's proof data
     * @dev Creates a structured JSON object containing inputs, proof, root, and leaf
     * @param _inputs Stringified array of input values (address and amount)
     * @param _proof Stringified array of proof hashes
     * @param _root The Merkle root hash as a string
     * @param _leaf The leaf hash as a string
     * @return A formatted JSON string for this entry
     */
    function generateJsonEntries(string memory _inputs, string memory _proof, string memory _root, string memory _leaf)
        internal
        pure
        returns (string memory)
    {
        string memory result = string.concat(
            "{",
            '"inputs":',
            _inputs,
            ",",
            '"proof":',
            _proof,
            ",",
            '"root":"',
            _root,
            '",',
            '"leaf":"',
            _leaf,
            '"',
            "}"
        );

        return result;
    }

    /*//////////////////////////////////////////////////////////////
                               FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Main entry point for Merkle proof generation
     * @dev Performs the following steps:
     *      1. Reads input data from JSON file
     *      2. Parses addresses and amounts based on type definitions
     *      3. Constructs leaf hashes using double-keccak256
     *      4. Generates Merkle proofs for each leaf
     *      5. Writes the complete output to JSON file
     *
     *      The leaf hash is computed as:
     *      keccak256(bytes.concat(keccak256(ltrim64(abi.encode([address, amount])))))
     *
     *      ltrim64 removes the offset and length from the encoded bytes array
     *      since the data array is declared in memory
     */
    function run() public {
        console.log("Generating Merkle Proof for %s", inputPath);

        // Phase 1: Parse input data and construct leaf hashes
        for (uint256 i = 0; i < count; ++i) {
            string[] memory input = new string[](types.length);
            bytes32[] memory data = new bytes32[](types.length);

            for (uint256 j = 0; j < types.length; ++j) {
                if (compareStrings(types[j], "address")) {
                    address value = elements.readAddress(getValuesByIndex(i, j));
                    // Cast address (20 bytes) -> uint160 -> uint256 (32 bytes) -> bytes32
                    data[j] = bytes32(uint256(uint160(value)));
                    input[j] = vm.toString(value);
                } else if (compareStrings(types[j], "uint")) {
                    uint256 value = vm.parseUint(elements.readString(getValuesByIndex(i, j)));
                    data[j] = bytes32(value);
                    input[j] = vm.toString(value);
                }
            }

            // Create leaf hash using double-keccak256 to prevent preimage attacks
            // ltrim64 removes the memory array offset and length prefix
            leafs[i] = keccak256(bytes.concat(keccak256(ltrim64(abi.encode(data)))));
            inputs[i] = stringArrayToString(input);
        }

        // Phase 2: Generate proofs and construct output JSON
        for (uint256 i = 0; i < count; ++i) {
            string memory proof = bytes32ArrayToString(m.getProof(leafs, i));
            string memory root = vm.toString(m.getRoot(leafs));
            string memory leaf = vm.toString(leafs[i]);
            string memory input = inputs[i];

            outputs[i] = generateJsonEntries(input, proof, root, leaf);
        }

        // Write the final output
        output = stringArrayToArrayString(outputs);
        vm.writeFile(string.concat(vm.projectRoot(), outputPath), output);

        console.log("DONE: The output is found at %s", outputPath);
    }
}
